행렬 : 행렬공식에 의해 아래의 숫자들이 변형되는 것을 의미한다.
0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f

행 : 세로
열 : 가로

1. 행렬의 곱셈
	1) 규칙 : 행렬의 식에서 왼쪽행렬의 열과 오른쪽행렬의 행이 같아야만 곱셈공식을 사용할 수 있다.
					즉, 1x4 행렬 A와 4x4 행렬 B가 존재할때 행렬의 곱셈규칙이 성립하며,
					두 행렬 A,B를 곱하면 1x4의 행렬을 결과값으로 반환한다.

	2) 계산 방법 : 4x4 A행렬과 4x4 B행렬을 곱셈으로 아래와 같이 설명한다
		A												B											C
		A00 A01 A02 A03		*		B00 B01 B02 B03  =		C00 C01 C02 C03
		A10 A11 A12 A13				B10 B11 B12 B13			C10 C11 C12 C13
		A20 A21 A22 A23				B20 B21 B22 B23			C20 C21 C22 C23
		A30 A31 A32 A33				B30 B31 B32 B33			C30 C31 C32 C33

		=> 왼쪽의 원소값과 오른쪽의 원소값을 모두 곱하여 더한값이 결과값이 된다.
			  즉, 아래와 같은 결과를 도출과정을 통해 C행렬이 반환된다.
		Cij =  Ai0*b0j + Ai1*b1j + Ai2*b2j + Ai3*b3j
		C00 =  A00*B00 + A01*B10 + A02*B20 + A03*B30
		C01 =  A00*B01 + A01*B11 + A02*B21 + A03*B31
		C02 =  A00*B02 + A01*B12 + A02*B22 + A03*B32
		C03 =  A00*B03 + A01*B13 + A02*B23 + A03*B33
		...

2. 항등행렬
	1) 의미 : 단위행렬이라고도하며, 주대각선(LeftTop->RightBottom)의 원소값이 모두 1이고,
					나머지 원소의 값이 모두 0인 행렬을 말한다.

	2) 일반적인 행렬의 곱셈에서는 교환법칙이 성립하지 않으나, 어떠한 행렬과 항등행렬을 곱하는 공식이 존재할때
		 항상 곱해진 행렬을 결과값으로 반환하기 때문에 교환법칙이 성립한다.

	3) 예시
		A						B(항등행렬)			C						B(항등행렬)		A								C
		2 0 0 0     *	1 0 0 0			=		2 0 0 0			1 0 0 0			*	2 0 0 0			=		2 0 0 0
		0 2 0 0			0 1 0 0					0 2 0 0			0 1 0 0				0 2 0 0					0 2 0 0
		0 0 2 0			0 0 1 0					0 0 2 0			0 0 1 0				0 0 2 0					0 0 2 0
		0 0 0 2			0 0 0 1					0 0 0 2			0 0 0 1				0 0 0 2					0 0 0 2

	4) 즉, A차원 행렬이 존재할때 이 행렬을 항등행렬과 곱하게 되면 A차원 행렬이 그대로 반환된다.

	5) 본 다이렉트 엔진에서 항등행렬을 기본값으로 설정하여 사용한다.

3. 벡터와 행렬의 곱셈
	1) 3D 공간에서의 벡터는 x,y,z,w값을 가지는 벡터이며 이를 행렬과 같이 설명한다면,
		 1x4 행렬이라고 할 수 있다.
		 이때 다이렉트에서는 4x4행렬을 통하여 위치/크기/회전 변형을 일으키므로,
		 이 벡터와 행렬을 곱하게 되면 벡터를 반환한다.
		 즉, 1x4 벡터 * 4x4 차원행렬 = 1x4 벡터 반환

4. 4x4 행렬을 사용하는 이유
	1) 일반적으로 벡터를 이용하여 곱하거나 더하거나 감하여 크기/위치/회전 변형을 일으킨다.
		 이는 연산량이 비교적 많으며, 비효율적이다.
	2) 하지만 4x4행렬을 이용하여 크기/위치/회전 변형을 하고자 하면 행렬의 원소값으로 
		 3가지변형을 한번에 처리가능한다.
	3) 그러므로 본 엔진에서는 행렬을 이용하여 각 물체의 크기/위치/회전 변형을 일으키고,
		 차원(공간)이동에 있어서 크기/위치/회전 변형을 일으키도록한다.
	4) 크기만을 변형하는 행렬이라면 3x3 행렬로 가능하나, 이동/회전은 표현이 불가하다.
	
5. 크기변환 행렬 : 벡터 B(1, 1, 1, w)의 크기를 변환하는 행렬 => B * A
	A(기본)			3배크게		A(크기행렬)
	1  0  0  0		 ->			3  0  0  0
	0  1  0  0					0  3  0  0
	0  0  1  0					0  0  3  0
	0  0  0  1					0  0  0  1

6. 위치변환 행렬 : 벡터 B(x, y, z, 1)의 위치를 변환하는 행렬 -> w가 1로 변환 => B * A
	A(기본)			10이동		 A(위치행렬)
	1  0  0  0		 ->			 1  0  0  0
	0  1  0  0					 0  1  0  0
	0  0  1  0					 0  0  1  0
	0  0  0  1					10 10 10  1

7. 회전변환 행렬 : 벡터 B(x, y, z, w)의 회전를 변환하는 행렬 -> 회전행렬은 크기행렬에 영향을 끼친다. => B * A
-> 실질적인 크기가 변화하지는 않으나, 물체가 회전하게되면 화면상에서의 물체는 면적이 달라지므로 크기에 영향을 줄 수 있다.
-> 무조건 그 세계(공간)의 3개축의 단위벡터로 구성되는 것이 회전 행렬이다.
-> 크기가 1인 세개의 벡터를 기준으로 회전행렬이 생성된다.
	1) X축 회전
	NextVector.y = _OriginVector.y * cosf(_Radian) - _OriginVector.z * sinf(_Radian);
	NextVector.z = _OriginVector.y * sinf(_Radian) + _OriginVector.z * cosf(_Radian);
	NextVector.x = _OriginVector.x;

		1		0		0		0
		0		cosf	sinf	0
	=>	0		-sinf	cosf	0
		0		0		0		1

	2) Y축 회전
	NextVector.z = _OriginVector.z * cosf(_Radian) - _OriginVector.x * sinf(_Radian);
	NextVector.x = _OriginVector.z * sinf(_Radian) + _OriginVector.x * cosf(_Radian);
	NextVector.y = _OriginVector.y;

		cosf	0		-sinf	0
		0		1		0		0
	=>	sinf	0		cosf	0
		0		0		0		1

	3) Z축 회전
	NextVector.x = _OriginVector.x * cosf(_Radian) - _OriginVector.y * sinf(_Radian);
	NextVector.y = _OriginVector.x * sinf(_Radian) + _OriginVector.y * cosf(_Radian);
	NextVector.z = _OriginVector.z;
	
		cosf	sinf	0	0
		-sinf	cosf	0	0
	=>	0		0		1	0
		0		0		0	1

-> 이렇게 계산한 각 축의 회전행렬을 모두 곱하여 어떠한 벡터에 회전변형을 일으킨다.





